<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">

<mapper namespace="root.SqlMapper">
    <select id="selectWord" resultType="map">
        select * from llm_word w where w.type != 'opener'
    </select>
    <select id="selectSymbolWord" resultType="map">
        select * from llm_word w where w.type = '기호'
    </select>
    <select id="selectContext" resultType="map">select * from plm_context c</select>
    <select id="selectCompound" resultType="map">select * from llm_word_compound c</select>
    <select id="selectGenerationTarget" resultType="root.UltronContext">
        select wq.*, cutter.n rcutter, lcutter.very_first noneOpener,
        exists (select 1 from plm_ultron_closer closer where closer.context = wq.context) closerContext,
        exists (select 1 from plm_ultron_experienced_opener exOpener where exOpener.context = wq.context) exOpener
        from (
            select sq.leftword, sq.rightword, sq.context, lw.word lw, rw.word rw, sq.cnt, sq.space, max(sq.pri) pri, count(*) rcnt
            from llm_word lw, llm_word rw, (
                select c.leftword, c.rightword, c.cnt, c.space, uc.i, os.n = uc.sentence pri, uc.context,
                row_number() over (partition by ifnull(os.n, container.sentence), uc.context, pri, container.i order by uc.i) rn
                from plm_ultron_context uc, plm_context c, (
                    select uc.sentence, p.i from plm_ultron_context uc, plm_context c, (
                    <foreach collection="list" item="item" separator=" union all " index="i">select #{item.n} n, #{i} i, #{item.rightword} r</foreach>
                    ) p
                    where uc.context = c.n
                    and c.leftword = p.n
                    and c.rightword = p.r
                    group by uc.sentence, p.i
                ) container left join plm_ultron_sentence os on container.sentence = os.target
                where ifnull(os.n, container.sentence) = uc.sentence
                and uc.context = c.n
            ) sq
            where sq.leftword = lw.n and sq.rightword = rw.n
            group by sq.leftword, sq.rightword, sq.rn
            order by pri desc, rcnt desc, sq.i limit #{limit}
        ) wq left join plm_cutter cutter on wq.rightword = cutter.wn
        left join plm_cutter lcutter on lcutter.very_first and wq.leftword = lcutter.wn
    </select>
    <select id="selectConsumer" resultType="root.mind.ConsumeContext">
        select DISTINCT mer.context mer, mable.context mable from (
            select t.n, max(t.ci) ci, t.context from plm_token t, llm_word w
            where t.rightword = w.n
            and w.type = '무엇'
            group by t.n, t.context
        ) mer, (
            select t.n, min(t.ci) ci, t.context from plm_token t, llm_word w
            where t.leftword = w.n
            and w.type in ('무엇', '대명사', '0')
            group by t.n, t.context
        ) mable
        where mer.n = mable.n
        and mer.ci >= mable.ci
        -- order by mer
    </select>
    <select id="selectCutterPattern" resultType="map">
        select s.n, cutter.n cutter -- , cutter.word, cutter.`type`
        from plm_ultron_sentence s, plm_ultron_context uc, plm_context c, plm_cutter cutter
        where s.target is not NULL
        and s.n = uc.sentence
        and uc.context = c.n
        and c.rightword = cutter.wn -- 첫 단어 즉 오프너는 버린다, 조사 오프너가 있을 수는 있다.. 근데 그 예외는 포기/감수한다 ㅋ
        order by uc.i -- s.n, uc.i
    </select>
    <select id="selectBuildingPattern" resultType="root.mind.BuildingPatternItem">
        select wq.sentence, wq.context, wq.lc, wq.cw, wq.rt, wq.rightword
        from (
            select uc.sentence, uc.i, uc.context, exists(select 1 from plm_cutter ct where c.leftword = ct.wn) lc,
            exists(select 1 from llm_word_compound sq where sq.word = c.rightword) cw,
            (select sq.type from llm_word sq where sq.n = c.rightword) rt, c.rightword
            from plm_ultron_context uc, plm_context c
            where uc.context = c.n
        ) wq
        where wq.lc or wq.cw or wq.rt = '0'
        order by wq.sentence, wq.i
    </select>
    <select id="selectTriplet" resultType="root.mind.Triplet">
        select distinct sq.lead, sq.context from (
        select uc.sentence, uc.i, LAG(uc.context) over(partition by uc.sentence order by uc.i) lead, uc.context from plm_ultron_context uc
        ) sq
        where sq.i != 0
    </select>

    <insert id="insertUltronCloser">
        insert into plm_ultron_closer
        select distinct uc.context from plm_ultron_sentence s, plm_ultron_context uc, (
        select uc.sentence, max(uc.i) i from plm_ultron_context uc
        group by uc.sentence
        ) lc
        where s.n = uc.sentence
        and s.target is not null
        and uc.sentence = lc.sentence and uc.i = lc.i
    </insert>
    <insert id="insertExperiencedOpener">
        insert INTO plm_ultron_experienced_opener
        select distinct uc.context from plm_ultron_context uc
        where uc.i = 0
    </insert>

    <delete id="deleteUltronCloser">delete from plm_ultron_closer</delete>
    <delete id="deleteExperiencedOpener">delete from plm_ultron_experienced_opener</delete>
</mapper>